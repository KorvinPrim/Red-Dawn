import pygamefrom os import pathimport timefrom sys import exitpygame.init()font = pygame.font.Font(path.join('data_font', 'Game_font.ttf'), 25)  # Загрузка шрифтаscreen = pygame.display.set_mode((800, 648))pygame.display.set_caption("Red dawn")background_steps = 0running = Truecore_cycle = Truepygame.mouse.set_visible(False)all_sprites = pygame.sprite.LayeredUpdates(_layer=0)active_ammunition_list = []active_enemy = []heroded_shell = []explosion_list = []class Sound:    def __init__(self, background, death, win, shot, pause, start, exp):        pygame.mixer.pre_init(44100, -16, 1, 512)        pygame.mixer.init()        self.background = pygame.mixer.Sound(background)        self.death = pygame.mixer.Sound(death)        self.win = pygame.mixer.Sound(win)        self.shot = pygame.mixer.Sound(shot)        self.shot.set_volume(0.4)        self.pause = pygame.mixer.Sound(pause)        self.start = pygame.mixer.Sound(start)        self.exp = pygame.mixer.Sound(exp)        self.exp.set_volume(0.4)    def sound_background(self, play=True):        return self.background    def sound_death(self, play=True):        return self.death    def sound_win(self, play=True):        return self.win    def sound_shot(self, play=True):        return self.shot    def sound_pause(self, play=True):        return self.pause    def sound_start(self, play=True):        return self.start    def sound_exp(self, play=True):        return self.expclass Score:    def __init__(self):        try:  #            file = open('Red_dawn_score.txt')  #        except FileNotFoundError:  #            file = open('Red_dawn_score.txt', 'w')  # #Загрузка очков игрока            file.write(str(0))  #            file.close()  #        finally:  #            file = open('Red_dawn_score.txt')  #            self.player_points = int(file.read().strip())            file.close()    def adding_points(self, scor):        self.player_points += scor    def watch_points(self):        return self.player_points    def save(self):        file = open('Red_dawn_score.txt', 'w')  # #Загрузка очков игрока        file.write(str(self.player_points))class medium_projectile:    def __init__(self, ship_position, position_of_sight, shell_image, speed, enemy=False, damage=10, ):        sound.sound_shot().play()        self.damage = damage        self.enemy = enemy        self.shell = adding_to_sprites('Shell', shell_image)        self.shell.rect.x = ship_position[0] + 137        self.shell.rect.y = ship_position[1] + 7        distance_to_x = int((ship_position[0] + 150) - (position_of_sight[0] + 35))        distance_to_y = int((ship_position[1]) - (position_of_sight[1] + 35))        way = int(pow(distance_to_x ** 2 + distance_to_y ** 2, 0.5))        self.speed_y = distance_to_y / -way * speed        self.speed_x = distance_to_x / -way * speed        # active_ammunition_list.append([Shell,(speed_x,speed_y),enemy])    def return_sprite(self):        return self.shell    def return_speed(self):        return (self.speed_x, self.speed_y)    def return_belonging(self):        return self.enemy    def return_damage(self):        return self.damageclass Maskat():    def __init__(self, x0, y0, sprite):        self.x0 = x0        self.y0 = y0        self.life = 50        self.dead = False        self.sprite = sprite    def return_sprite(self):        return self.sprite    def name(self):        return 'Maskat'    def position(self):        return self.x0, self.y0    def attack_time(self):        return False    def render(self, damage):        self.x0 -= 3        if 550 < self.x0 < 800:            self.y0 -= 2        if 275 < self.x0 < 550:            self.y0 += 3        if 0 < self.x0 < 275:            self.y0 -= 2        #        if 600 < self.x0 < 650:        #            self.y0 += 2        #        if 500 < self.x0 < 600:        #            self.y0 -= 1        #        if 400 < self.x0 < 500:        #            self.y0 += 1        #        if 300 < self.x0 < 400:        #            self.y0 -= 2        #        if 200 < self.x0 < 300:        #            self.y0 += 2        #        if 100 < self.x0 < 200:        #            self.y0 -= 1        #        if 0 < self.x0 < 100:        #            self.y0 += 1        self.life -= damage        if self.life <= 0:            self.dead = True        return self.x0, self.y0, self.deadclass Juggernaut():    def __init__(self, x0, y0, sprite, time):        self.x0 = x0        self.y0 = y0        self.life = 200        self.dead = False        self.time = time        self.sprite = sprite    def return_sprite(self):        return self.sprite    def name(self):        return 'Juggernaut'    def position(self):        return self.x0 - 150, self.y0    def attack_time(self):        time = pygame.time.get_ticks()        if (time - self.time) > 500:            self.time = time            return 10        return False    def render(self, damage):        self.x0 -= 2        if 550 < self.x0 < 800:            self.y0 -= 1        if 275 < self.x0 < 550:            self.y0 += 1        if 0 < self.x0 < 275:            self.y0 -= 1            #        if 600 < self.x0 < 650:            #            self.y0 += 2            #        if 500 < self.x0 < 600:            #            self.y0 -= 1            #        if 400 < self.x0 < 500:            #            self.y0 += 1            #        if 300 < self.x0 < 400:            #            self.y0 -= 2            #        if 200 < self.x0 < 300:            #            self.y0 += 2            #        if 100 < self.x0 < 200:            #            self.y0 -= 1            #        if 0 < self.x0 < 100:            #            self.y0 += 1        self.life -= damage        if self.life <= 0:            self.dead = True        return self.x0, self.y0, self.deadclass Boss():    def __init__(self, x0, y0, sprite_one_stage, sprite_two_stage, sprite_three_stage, time):        self.x0 = x0        self.y0 = y0        self.life = 1000        self.two_stage = True        self.three_stage = True        self.dead = False        self.time = time        self.sprite = sprite_one_stage        self.sprite_two_stage = sprite_two_stage        self.sprite_three_stage = sprite_three_stage    def return_sprite(self):        return self.sprite    def name(self):        return 'Boss'    def position(self):        return self.x0 - 65, self.y0 + 88    def attack_time(self):        time = pygame.time.get_ticks()        if (time - self.time) > 500:            self.time = time            return 5        return False    def render(self, damage):        if 600 < self.x0 < 1200:            self.x0 -= 1        if 500 < self.x0 <= 600 and self.y0 == 300:            self.x0 -= 1        if 500 == self.x0 and 0 < self.y0 < 401:            self.y0 -= 1        if self.y0 == 0 and 400 <= self.x0 < 600:            self.x0 += 1        if 600 == self.x0 and 0 <= self.y0 < 401:            self.y0 += 1        self.life -= damage        if self.life <= 0:            self.dead = True            if self.two_stage:                self.sprite.kill()                self.sprite = adding_to_sprites('boss_image_2', self.sprite_two_stage, 1)                self.sprite.rect.x = self.x0                self.sprite.rect.y = self.y0                self.life = 1500                self.two_stage = False                self.dead = False            elif self.three_stage:                self.life = 2000                self.sprite.kill()                self.sprite = adding_to_sprites('boss_image_3', self.sprite_three_stage, 1)                self.sprite.rect.x = self.x0                self.sprite.rect.y = self.y0                self.three_stage = False                self.dead = False        return self.x0, self.y0, self.deadclass Hero:    def __init__(self, hp):        self.hp = hp    def render(self, position_x, position_y, key, damage=0):        self.hp -= damage        move_moment_x = 0        move_moment_y = 0        if key[pygame.K_s]:            if position_y < 530:                move_moment_y = 3        elif key[pygame.K_w]:            if position_y > 0:                move_moment_y = -3        if key[pygame.K_d]:            if position_x < 650:                move_moment_x = 3        elif key[pygame.K_a]:            if position_x > 0:                move_moment_x = -5        return move_moment_x, move_moment_y, self.hpclass Enemies_of_location:    def __init__(self):        self.wave1_boll = True        self.wave1_bol2 = True        self.wave1_bol3 = True        self.wave1_bol4 = True        self.wave1_bol5 = True        self.wave1_bol6 = True        self.wave1_bol7 = True        self.boss = True    def sample(self, step):        if step == 1 and self.wave1_boll:            self.wave1_boll = False            return self.wave_1()        elif step == 3 and self.wave1_bol2:            self.wave1_bol2 = False            return self.wave_2()        elif step == 5 and self.wave1_bol3:            self.wave1_bol3 = False            return self.wave_3()        elif step == 7 and self.wave1_bol4:            self.wave1_bol4 = False            return self.wave_4()        elif step == 9 and self.wave1_bol5:            self.wave1_bol5 = False            return self.wave_5()        elif step == 11 and self.wave1_bol6:            self.wave1_bol6 = False            return self.wave_6()        elif step == 13 and self.wave1_bol7:            self.wave1_bol7 = False            return self.wave_7()        elif step == 15 and self.boss:            self.boss = False            return self.boss_wave()        else:            return 0, 0    def wave_1(self):        return [4, 1]    def wave_2(self):        return [4, 0]    def wave_3(self):        return [8, 0]    def wave_4(self):        return [8, 0]    def wave_5(self):        return [8, 0]    def wave_6(self):        return [0, 2]    def wave_7(self):        return [0, 2]    def boss_wave(self):        return [12, 0, 'BOSS']class Menu:    def __init__(self, data_item, bacgraund, sound):        self.data_item = data_item        self.bacgraund = bacgraund        self.sound = sound    def render(self, screen, font, namber_item):        for i in self.data_item:            additive = (str(scor_point.watch_points()) if i[2] == 'Score:' else '')            if i[5] == namber_item:                screen.blit(font.render(i[2] + additive, True, i[4]), (i[0], i[1]))            else:                screen.blit(font.render(i[2] + additive, True, i[3]), (i[0], i[1]))    def menu_render(self):        global screen        global mouse_position        global running        pygame.mixer.pause()        self.sound.play()        pygame.mouse.set_visible(True)        play = True        focus_button = 0        font_menu = pygame.font.Font(path.join('data_font', 'Game_font.ttf'), 50)        while play:            screen.fill((0, 0, 0))            screen.blit(self.bacgraund, (0, 0))            mp = pygame.mouse.get_pos()            for i in self.data_item:                if mp[0] > i[0] and mp[0] < i[0] + 155 and mp[1] > i[1] and mp[1] < i[1] + 55:                    focus_button = i[5]            self.render(screen, font_menu, focus_button)            for event in pygame.event.get():                if event.type == pygame.QUIT:                    exit()                if event.type == pygame.KEYDOWN:                    if event.key == pygame.K_ESCAPE:                        play = False                    if event.key == pygame.K_UP:                        if focus_button > 0:                            focus_button -= 1                    if event.key == pygame.K_DOWN:                        if focus_button < len(self.data_item) - 1:                            focus_button += 1                if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1 \                        or pygame.key.get_pressed()[pygame.K_RETURN]:                    for i in self.data_item:                        if i[5] == focus_button:                            if i[2] == 'Start' or i[2] == 'Continue':                                pygame.mixer.unpause()                                self.sound.stop()                                play = False                                running = True                            if i[2] == 'Exit to menu':                                pygame.mixer.unpause()                                self.sound.stop()                                play = False                                running = False                            if i[2] == 'Exit':                                exit()                            if i[2] == 'Restart':                                pygame.mixer.unpause()                                self.sound.stop()                                return 1            pygame.display.flip()def creation_of_explosion(exp_poz_x, exp_poz_y, img1, hero=False, boss=False):    sound.sound_exp().play(maxtime=1000)    Exp = adding_to_sprites('Exp', img1)    Exp.rect.x = exp_poz_x    Exp.rect.y = exp_poz_y    if hero:        explosion_list.append([Exp, exp_poz_x, exp_poz_y, 0, ])        explosion_list.append([Exp, exp_poz_x - 10, exp_poz_y + 20, 0, ])        explosion_list.append([Exp, exp_poz_x - 20, exp_poz_y - 20, 0, ])        explosion_list.append([Exp, exp_poz_x - 30, exp_poz_y, 0, ])        explosion_list.append([Exp, exp_poz_x - 60, exp_poz_y, 0, ])        explosion_list.append([Exp, exp_poz_x + 10, exp_poz_y, 0, ])        explosion_list.append([Exp, exp_poz_x + 20, exp_poz_y, 0, ])        explosion_list.append([Exp, exp_poz_x + 30, exp_poz_y + 30, 0, 'HERO'])    if boss:        explosion_list.append([Exp, exp_poz_x, exp_poz_y, 0, ])        explosion_list.append([Exp, exp_poz_x - 10, exp_poz_y + 50, 0, ])        explosion_list.append([Exp, exp_poz_x - 20, exp_poz_y + 100, 0, ])        explosion_list.append([Exp, exp_poz_x - 30, exp_poz_y + 150, 0, ])        explosion_list.append([Exp, exp_poz_x - 60, exp_poz_y + 200, 0, ])        explosion_list.append([Exp, exp_poz_x + 10, exp_poz_y + 250, 0, ])        explosion_list.append([Exp, exp_poz_x + 20, exp_poz_y + 300, 0, ])        explosion_list.append([Exp, exp_poz_x, exp_poz_y, 0, ])        explosion_list.append([Exp, exp_poz_x + 150, exp_poz_y + 50, 0, ])        explosion_list.append([Exp, exp_poz_x + 150, exp_poz_y + 100, 0, ])        explosion_list.append([Exp, exp_poz_x + 150, exp_poz_y + 150, 0, ])        explosion_list.append([Exp, exp_poz_x + 150, exp_poz_y + 200, 0, ])        explosion_list.append([Exp, exp_poz_x + 150, exp_poz_y + 250, 0, ])        explosion_list.append([Exp, exp_poz_x + 150, exp_poz_y + 300, 0, ])        explosion_list.append([Exp, exp_poz_x + 50, exp_poz_y + 50, 0, ])        explosion_list.append([Exp, exp_poz_x + 50, exp_poz_y + 100, 0, ])        explosion_list.append([Exp, exp_poz_x + 50, exp_poz_y + 150, 0, ])        explosion_list.append([Exp, exp_poz_x + 50, exp_poz_y + 200, 0, ])        explosion_list.append([Exp, exp_poz_x + 50, exp_poz_y + 250, 0, ])        explosion_list.append([Exp, exp_poz_x + 50, exp_poz_y + 300, 0, ])        explosion_list.append([Exp, exp_poz_x + 50, exp_poz_y, 0, 'BOSS'])    else:        explosion_list.append([Exp, exp_poz_x, exp_poz_y, 0])def render_of_explosion(*img):    for i in explosion_list:        if i[3] != 5:            Exp = adding_to_sprites('Exp', img[i[3]])            Exp.rect.x = i[1]            Exp.rect.y = i[2]            try:                explosion_list.append([Exp, i[1], i[2], i[3] + 1, i[4]])            except IndexError:                explosion_list.append([Exp, i[1], i[2], i[3] + 1])            explosion_list.remove(i)            i[0].kill()        else:            if 'HERO' in i:                return 1            if 'BOSS' in i:                return 2            i[0].kill()            explosion_list.remove(i)def load_image(name, colorkey=None):  # Загрузка картинки    fullname = path.join('data', name)    try:        image = pygame.image.load(fullname)        if colorkey is not None:            if colorkey is -1:                colorkey = image.get_at((0, 0))                image = image.convert_alpha()            image.set_colorkey(colorkey)        return image    except pygame.error as message:        print('Cannot load image:', name)        raise SystemExit(message)def adding_to_sprites(name_sprait, img_sprait, namber_layer=1):  # Создание спрайта    name_sprait_for_ceature = name_sprait    sprait_for_creature = img_sprait    name_sprait_for_ceature = pygame.sprite.Sprite()    name_sprait_for_ceature.image = sprait_for_creature    mask_name_sprait_for_ceature = pygame.mask.from_surface(sprait_for_creature)    name_sprait_for_ceature.rect = name_sprait_for_ceature.image.get_rect()    all_sprites.add(name_sprait_for_ceature, layer=namber_layer)    return name_sprait_for_ceaturedef adding_to_sprites_for_text(name_sprait, img_sprait, namber_layer=1):  # Создание спрайта    name_sprait_for_ceature = name_sprait    name_sprait_for_ceature = pygame.sprite.Sprite()    name_sprait_for_ceature.image = img_sprait    name_sprait_for_ceature.rect = name_sprait_for_ceature.image.get_rect()    all_sprites.add(name_sprait_for_ceature, layer=namber_layer)    return name_sprait_for_ceaturescor_point = Score()life_HP = adding_to_sprites_for_text('life_HP', font.render(str(100), True, (0, 255, 0)), 3)scor_sprite = adding_to_sprites_for_text('Score',                                         font.render('Score:' + str(scor_point.watch_points()), True, (255, 0, 0)), 4)ei1 = load_image('explosion\explosion_1.png', -1)ei2 = load_image('explosion\explosion_2.png', -1)ei3 = load_image('explosion\explosion_3.png', -1)ei4 = load_image('explosion\explosion_4.png', -1)ei5 = load_image('explosion\explosion_5.png', -1)ei6 = load_image('explosion\explosion_6.png', -1)def background_movement(first_fon, last_fon, speed):  # Пролистывание фона    global background_steps    if last_fon.rect.x < 0:        first_fon.rect.x = 0        last_fon.rect.x = 800        background_steps += 1    first_fon.rect.x -= speed    last_fon.rect.x -= speeddef aim(Name_picture_aim, pos):  # Перемещение указателя мышки    Name_picture_aim.rect.x = pos[0]    Name_picture_aim.rect.y = pos[1]def movement_of_the_main_character(hero, Ship, Direction):  # Перемещение главного героя и рендер статус бара    global heroded_shell    global life_HP    global scor_sprite    if len(heroded_shell) == 0:        move_x, move_y, life = hero.render(Ship.rect.x, Ship.rect.y, Direction)        if life > 0:            pygame.sprite.Sprite.kill(life_HP)            life_HP = adding_to_sprites_for_text('life_HP', font.render(str(life), True, (0, 255, 0)), 4)            pygame.sprite.Sprite.kill(scor_sprite)            scor_sprite = adding_to_sprites_for_text('Score',                                                     font.render('Score:' + str(scor_point.watch_points()), True,                                                                 (255, 0, 0)), 4)            life_HP.rect.x = 400            life_HP.rect.y = 607            scor_sprite.rect.x = 350            scor_sprite.rect.y = 0            Ship.rect.x += move_x            Ship.rect.y += move_y    else:        for i in heroded_shell:            move_x, move_y, life = hero.render(Ship.rect.x, Ship.rect.y, Direction, i)            heroded_shell.remove(i)            if life > 0:                pygame.sprite.Sprite.kill(life_HP)                life_HP = adding_to_sprites_for_text('life_HP', font.render(str(life), True, (0, 255, 0)), 4)                life_HP.rect.x = 400                life_HP.rect.y = 607                Ship.rect.x += move_x                Ship.rect.y += move_y            else:                creation_of_explosion(Ship.rect.x + 60, Ship.rect.y - 35, ei1, hero=True)                pygame.sprite.Sprite.kill(life_HP)                life_HP = adding_to_sprites_for_text('life_HP', font.render(str(0), True, (0, 255, 0)), 4)                life_HP.rect.x = 400                life_HP.rect.y = 607    ([(heroded_shell.append(30) if pygame.sprite.collide_mask(Ship, j.return_sprite()) else False) for j in      active_enemy])    ([(heroded_shell.append(j.return_damage()) if (    pygame.sprite.collide_mask(Ship, j.return_sprite()) and j.return_belonging()) else False) for j in      active_ammunition_list])    ([(pygame.sprite.Sprite.kill(j.return_sprite()) if (    pygame.sprite.collide_mask(Ship, j.return_sprite()) and j.return_belonging()) else False) for j in      active_ammunition_list])    ([(active_ammunition_list.remove(j) if (    pygame.sprite.collide_mask(Ship, j.return_sprite()) and j.return_belonging()) else False) for j in      active_ammunition_list])def projectile_movement():  # Преремещение снарядов    for i in active_ammunition_list:        if i.return_sprite().rect.x >= 800 or i.return_sprite().rect.x <= -50 \                or i.return_sprite().rect.y >= 600 or i.return_sprite().rect.y <= -50:            active_ammunition_list.remove(i)            i.return_sprite().kill()        else:            i.return_sprite().rect.x += i.return_speed()[0]            i.return_sprite().rect.y += i.return_speed()[1]def creating_an_enemy(enemy_image, enemy_juggernaut_image, boss_image_one_stage, boss_image_two_stage,                      boss_image_three_stage, quantity):  # Создание врагов    y = 165    if 'BOSS' in quantity:        enemy_1 = adding_to_sprites('boss_image_1', boss_image_one_stage, 1)        enemy_1.rect.x = 1100        enemy_1.rect.y = 300        active_enemy.append(Boss(enemy_1.rect.x, enemy_1.rect.y, enemy_1, boss_image_two_stage, boss_image_three_stage,                                 pygame.time.get_ticks()))    for i in range(quantity[0]):        if 4 > i:            enemy = adding_to_sprites('enemy', enemy_image, 1)            enemy.rect.x = 800            enemy.rect.y = y            active_enemy.append(Maskat(enemy.rect.x, enemy.rect.y, enemy))            y += 70        elif 8 > i >= 4:            enemy = adding_to_sprites('enemy', enemy_image, 1)            enemy.rect.x = 870            enemy.rect.y = y            active_enemy.append(Maskat(enemy.rect.x, enemy.rect.y, enemy))            y -= 70        elif 7 < i < 12:            enemy = adding_to_sprites('enemy', enemy_image, 1)            enemy.rect.x = 940            enemy.rect.y = y            active_enemy.append(Maskat(enemy.rect.x, enemy.rect.y, enemy))            y += 70    y = 165    for i in range(quantity[1]):        if i > 3:            enemy = adding_to_sprites('enemy_juggernaut', enemy_juggernaut_image, 1)            enemy.rect.x = 870            enemy.rect.y = y            active_enemy.append(Juggernaut(enemy.rect.x, enemy.rect.y, enemy, pygame.time.get_ticks()))            y -= 200        else:            enemy = adding_to_sprites('enemy_juggernaut', enemy_juggernaut_image, 1)            enemy.rect.x = 800            enemy.rect.y = y            active_enemy.append(Juggernaut(enemy.rect.x, enemy.rect.y, enemy, pygame.time.get_ticks()))            y += 200class Moving_enemies:    def __init__(self, ship, **kwargs):        self.ship = ship        self.kwargs = kwargs    def render(self):        for i in active_enemy:            sprite = i.return_sprite()            damage_enemy = i.attack_time()            if (damage_enemy):                active_ammunition_list.append(medium_projectile(                    (i.position()), (self.ship.rect.x, self.ship.rect.y), self.kwargs['shell_image'], 5, True,                    damage=damage_enemy))            if sprite.rect.x <= -150 or sprite.rect.y >= 600 or sprite.rect.y <= -50:                active_enemy.remove(i)                sprite.kill()            else:                collided_shell = []                ([(collided_shell.append((j, 50)) if (                pygame.sprite.collide_mask(sprite, j.return_sprite()) and not j.return_belonging()) else False) for j in                  active_ammunition_list])                if pygame.sprite.collide_mask(sprite, self.ship):                    collided_shell.append((None, 100))                if len(collided_shell) == 0:                    x0, y0, status = i.render(0)                    sprite.rect.x = x0                    sprite.rect.y = y0                else:                    for j in collided_shell:                        x0, y0, status = i.render(j[1])                        if not status:                            try:                                active_ammunition_list.remove(j[0])                                j[0].return_sprite().kill()                            except ValueError:                                pass                            sprite.rect.x = x0                            sprite.rect.y = y0                        else:                            try:                                active_ammunition_list.remove(j[0])                                j[0].return_sprite().kill()                            except ValueError:                                pass                            creation_of_explosion(sprite.rect.x, sprite.rect.y, ei1)                            scor_point.adding_points(100)                            scor_point.save()                            if i.name() == 'Boss':                                creation_of_explosion(sprite.rect.x, sprite.rect.y, ei1, boss=True)                            active_enemy.remove(i)                            sprite.kill()def load_level_1():    global running    global active_ammunition_list    global active_enemy    global heroded_shell    global explosion_list    global background_steps    pygame.mixer.stop()    sound.sound_background().play()    # Создание основных картиноквввв игры    shell_image = load_image('shell.png', -1)    enemy_shell_image = load_image('enemy_shell.png', -1)    enemy_image = load_image('enemy.png', -1)    juggernaut_image = load_image('Dshgernaut.png', -1)    fon_city_image = load_image('Fon_city.png', -1)    aim_image = load_image('Aim.png', -1)    status_bar_image = load_image('status_bar.png', -1)    ship_image = load_image('Ship.png', -1)    boss_one_stage = load_image('boss_one_stage.png', -1)    boss_two_stage = load_image('boss_two_stage.png', -1)    boss_three_stage = load_image('boss_three_stage.png', -1)    # Создание основных спрайтов игры    fon_city_first = adding_to_sprites('fon_city_first', fon_city_image, 0)    fon_city_end = adding_to_sprites('fon_city_end', fon_city_image, 0)    aim_picture = adding_to_sprites('aim_picture', aim_image, 5)    # Создание статус бара    status_bar = adding_to_sprites('status_bar', status_bar_image, 2)    status_bar.rect.y = 48    # Создание главного героя    ship = adding_to_sprites('Ship', ship_image, 1)    hero = Hero(100)    ship.rect.y = 300    fon_city_end.rect.x += 800    timer = pygame.time.get_ticks()    Time = time.clock()    wait = pygame.time.Clock()    bilding_enemy = Enemies_of_location()  # Библиотека по шагам фона генерирует колличество врагов    number_of_enemies = (0, 0)    open_fire = False  # Переменная отвечает за постоянный огонь при нажатии мыши    dead = False    win = False    mouse_position = pygame.mouse.get_pos()    moving_enemies = Moving_enemies(ship, shell_image=enemy_shell_image)    while running:        pygame.mouse.set_visible(False)        wait.tick(100)        background_movement(fon_city_first, fon_city_end, 3)        creating_an_enemy(enemy_image, juggernaut_image, boss_one_stage, boss_two_stage, boss_three_stage,                          bilding_enemy.sample(background_steps))  # Передача колличества врагов для создания онных        movement_of_the_main_character(hero, ship, pygame.key.get_pressed())        projectile_movement()  # Расчёт положения снярядов        moving_enemies.render()        # Расчёт времени следующей атаки главного орудия        if pygame.time.get_ticks() - timer >= 100:            timer = pygame.time.get_ticks()            status_game = render_of_explosion(ei1, ei2, ei3, ei4, ei5)            if status_game == 1:  # Рендер взрывов                running = False                dead = True            elif status_game == 2:                running = False                win = True        aim(aim_picture, mouse_position)        if open_fire:            T_clock = time.clock()  # Расчёт времени следующей атаки главного орудия            if T_clock - Time >= 0.5:                Time = T_clock                active_ammunition_list.append(medium_projectile(                    (ship.rect.x, ship.rect.y), mouse_position, shell_image, 10, damage=50))        for event in pygame.event.get():            if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:                pause_menu_level_1.menu_render()                mouse_position = pygame.mouse.get_pos()            if event.type == pygame.MOUSEBUTTONDOWN:                if event.button == 1:                    T_clock = time.clock()  # Расчёт времени следующей атаки главного орудия                    if T_clock - Time >= 0.5:                        Time = T_clock                        active_ammunition_list.append(medium_projectile(                            (ship.rect.x, ship.rect.y), event.pos, shell_image, 10,                            damage=50))  # Создаёт патрон с картинкой, и                        # напрвлением и добавлеет его в активный лист                        open_fire = True            if event.type == pygame.MOUSEBUTTONUP:  # Отвечает за остановку огня                if event.button == 1:                    open_fire = False            if event.type == pygame.QUIT:  # Отвечает за выход из приложения                exit()            if pygame.mouse.get_focused():  # Отвечает за положение мышки                if event.type == pygame.MOUSEMOTION:                    mouse_position = event.pos            else:                mouse_position = (1000, 1000)        screen.fill((0, 0, 0))        all_sprites.draw(screen)        pygame.display.flip()        if not running:            background_steps = 0            pygame.sprite.Sprite.kill(fon_city_first)            pygame.sprite.Sprite.kill(fon_city_end)            pygame.sprite.Sprite.kill(aim_picture)            pygame.sprite.Sprite.kill(status_bar)            pygame.sprite.Sprite.kill(ship)            [i.return_sprite().kill() for i in active_ammunition_list]            active_ammunition_list = []            [i.return_sprite().kill() for i in active_enemy]            active_enemy = []            heroded_shell = []            [i[0].kill() for i in explosion_list]            explosion_list = []        if win:            if win_menu_level_1.menu_render() == 1:                running = True                load_level_1()        if dead:            if dead_menu_level_1.menu_render() == 1:                running = True                load_level_1()sound = Sound('data_sound/bacgraund.ogg', 'data_sound/dead.ogg', 'data_sound/win.ogg',              'data_sound/shot.ogg', 'data_sound/pause.ogg', 'data_sound/start.ogg',              'data_sound/exp.ogg')start_menu_list = [    (150, 200, 'Start', (255, 255, 255), (255, 0, 0), 0),    (150, 300, 'Exit', (255, 255, 255), (255, 0, 0), 1),    (300, 0, 'Score:', (255, 0, 0), (255, 0, 0), 4)]bacgraund_start_menu = pygame.image.load(path.join('data', 'menu_backgraund.png'))core_menu = Menu(start_menu_list, bacgraund_start_menu, sound.sound_start())list_label_for_pause = [    (100, 350, 'Continue', (255, 255, 255), (255, 0, 0), 0),    (100, 450, 'Exit to menu', (255, 255, 255), (255, 0, 0), 1),    (100, 550, 'Exit', (255, 255, 255), (255, 0, 0), 2),    (250, 0, 'Score:', (255, 0, 0), (255, 0, 0), 4)]bacgraund_pause_menu_lvl_1 = pygame.image.load(path.join('data', 'bg_pause_menu_level_1.png'))pause_menu_level_1 = Menu(list_label_for_pause, bacgraund_pause_menu_lvl_1, sound.sound_pause())list_label_for_dead_lvl_1 = [    (300, 100, 'You Died', (255, 0, 0), (255, 0, 0), 0),    (300, 300, 'Restart', (255, 255, 255), (255, 0, 0), 1),    (300, 400, 'Exit to menu', (255, 255, 255), (255, 0, 0), 2),    (300, 500, 'Exit', (255, 255, 255), (255, 0, 0), 3)]bacgraund_dead_menu_lvl_1 = pygame.image.load(path.join('data', 'Dead_lvl_1.png'))dead_menu_level_1 = Menu(list_label_for_dead_lvl_1, bacgraund_dead_menu_lvl_1, sound.sound_death())list_label_for_win_lvl_1 = [    (300, 100, 'You win!', (255, 0, 0), (255, 0, 0), 0),    (300, 300, 'Restart', (0, 255, 0), (255, 0, 0), 1),    (300, 400, 'Exit to menu', (0, 255, 0), (255, 0, 0), 2),    (300, 500, 'Exit', (0, 255, 0), (255, 0, 0), 3)]bacgraund_win_menu_lvl_1 = pygame.image.load(path.join('data', 'bacgraund_win_menu_lvl_1.png'))win_menu_level_1 = Menu(list_label_for_win_lvl_1, bacgraund_win_menu_lvl_1, sound.sound_win())while core_cycle:    core_menu.menu_render()    load_level_1()    for event in pygame.event.get():        if event.type == pygame.QUIT:  # Отвечает за выход из приложения            core_cycle = False            ##Test